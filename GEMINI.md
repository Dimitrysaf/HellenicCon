Ωραία, Δημήτρη. Ακολουθεί η ανανεωμένη έκθεση που ενσωματώνει όλα τα σημεία που συζητήσαμε: τον ενιαίο πίνακα, την ευέλικτη ιεραρχία, την αυτόματη αρίθμηση και την αναδιάταξη των άρθρων.

-----

### **Ανάλυση και Πρόταση Υλοποίησης για Δομημένο Ιστότοπο Νομικών Κειμένων**

Ο σκοπός αυτής της έκθεσης είναι η παρουσίαση ενός ολοκληρωμένου, λογικού και ευέλικτου μοντέλου για την κατασκευή ενός ιστότοπου που φιλοξενεί δομημένα κείμενα, όπως ένα Σύνταγμα. Η προσέγγιση αυτή βασίζεται στον διαχωρισμό του περιεχομένου από την εμφάνιση και στην χρήση σύγχρονων τεχνολογιών για τη δυναμική διαχείριση της ιεραρχίας.

-----

### **1. Λογική και Δομή Δεδομένων**

Η θεμελιώδης λογική είναι η χρήση ενός **ενιαίου πίνακα** (single table) που μπορεί να αναπαραστήσει ολόκληρη την ιεραρχία του Συντάγματος, από τους Τίτλους μέχρι τα Άρθρα. Αυτό το μοντέλο, γνωστό ως **Adjacency List**, προσφέρει απλότητα και μέγιστη ευελιξία.

  * **Ενιαίος Πίνακας `constitution_parts`**: Όλες οι εγγραφές, ανεξαρτήτως τύπου (τίτλος, κεφάλαιο, άρθρο), αποθηκεύονται στον ίδιο πίνακα.
  * **Ιεραρχία μέσω `parent_id`**: Η σύνδεση μεταξύ των στοιχείων γίνεται με το πεδίο `parent_id`. Ένα Άρθρο θα έχει ως `parent_id` το αναγνωριστικό του Κεφαλαίου στο οποίο ανήκει. Ένα στοιχείο που βρίσκεται στην κορυφή της ιεραρχίας (π.χ. ένας Τίτλος) θα έχει `parent_id` με τιμή `NULL`.
  * **Ευελιξία Οργάνωσης**: Αυτή η δομή επιτρέπει να προσθέτεις Άρθρα απευθείας κάτω από έναν Τίτλο ή ένα Κεφάλαιο, χωρίς να περιορίζεσαι σε μια σταθερή και προκαθορισμένη σειρά.

-----

### **2. Τεχνολογίες Υλοποίησης**

Για την κατασκευή της εφαρμογής, χρησιμοποιούμε ένα σύγχρονο και ευρέως διαδεδομένο τεχνολογικό stack που παρέχει πλήρη λειτουργικότητα ακόμα και στο δωρεάν επίπεδο (Hobbyist tier) της Vercel.

  * **Βάση Δεδομένων: Vercel Postgres**
      * Χρησιμοποιείται για την αποθήκευση του ενιαίου πίνακα `constitution_parts`.
  * **Backend & API: Next.js API Routes**
      * Δημιουργούνται λειτουργίες (serverless functions) που εκτελούν τη λογική της αυτόματης αρίθμησης και αναδιάταξης.
      * Εδώ γίνεται η επικοινωνία με τη βάση δεδομένων και η επιστροφή των δεδομένων σε μορφή **JSON**.
  * **Frontend: Next.js / React**
      * Η ιστοσελίδα δημιουργείται με εξαρτήματα (components) του React. Αυτά τα εξαρτήματα καλούν τα API routes για να ανακτήσουν και να εμφανίσουν τα δεδομένα.

-----

### **3. Σχήμα Βάσης Δεδομένων και Λογική Λειτουργίας**

#### **3.1 Σχήμα Πίνακα `constitution_parts`**

| Πεδίο       | Τύπος      | Περιγραφή                                                                                                   |
| :---------- | :--------- | :---------------------------------------------------------------------------------------------------------- |
| `id`        | `VARCHAR(255)`  | Μοναδικό αναγνωριστικό για κάθε στοιχείο (π.χ., `article-1234`).                                        |
| **`number`**| **`INT`** | Ο αριθμός του στοιχείου. Είναι το πεδίο που χρησιμοποιείται για την αυτόματη αρίθμηση και αναδιάταξη.         |
| `name`      | `VARCHAR(255)`  | Ο τίτλος ή η ονομασία του στοιχείου (π.χ., "Αρχικές Διατάξεις", "Η Ελληνική Ομοσπονδία").              |
| `content`   | `TEXT`      | Το κείμενο του στοιχείου. Θα είναι κενό για τους Τίτλους, Κεφάλαια και Τμήματα.                           |
| **`parent_id`**| **`VARCHAR(255)`**| Το ID του "γονέα" του στοιχείου. Είναι το κλειδί για την ιεραρχία και **υποχρεωτικό** για όλα εκτός από τους Τίτλους. |
| `type`      | `VARCHAR(50)`   | Ο τύπος του στοιχείου (`title`, `chapter`, `section`, `article`).                                      |

-----

#### **3.2 Αυτόματη Αρίθμηση και Αναδιάταξη**

Η λογική που περιέγραψες θα υλοποιηθεί στα Next.js API Routes.

  * **Προσθήκη Εγγραφής**:
    1.  Ο χρήστης επιλέγει τον `parent_id` και έναν αριθμό.
    2.  Το σύστημα ελέγχει αν ο επιλεγμένος αριθμός υπάρχει ήδη.
    3.  Αν υπάρχει, το API ενημερώνει όλες τις εγγραφές με τον ίδιο `parent_id` και μεγαλύτερο ή ίσο αριθμό, αυξάνοντας τον `number` κατά 1.
    4.  Τέλος, εισάγει τη νέα εγγραφή με τον επιλεγμένο αριθμό.
  * **Διαγραφή Εγγραφής**:
    1.  Ο χρήστης επιλέγει να διαγράψει μια εγγραφή.
    2.  Το API τη διαγράφει.
    3.  Αυτόματα, ενημερώνει όλες τις εγγραφές με τον ίδιο `parent_id` που είχαν μεγαλύτερο αριθμό, μειώνοντας τον `number` κατά 1, διατηρώντας έτσι τη συνέχεια.

-----

### **4. Παράδειγμα Σχημάτων API (API Schemas)**

Η νέα δομή απλοποιεί τις κλήσεις API.

#### **Παράδειγμα: Ανάκτηση Πλήρους Ιεραρχίας**

Για να φέρουμε ολόκληρη την ιεραρχία, θα κάνουμε μια αναδρομική ερώτηση στη βάση δεδομένων.

  * **Endpoint:** `/api/constitution`
  * **Μέθοδος:** `GET`
  * **Ενδεικτικό Σχήμα JSON:**
    ```json
    [
      {
        "id": "title-1",
        "number": 1,
        "name": "Αρχικές Διατάξεις",
        "content": null,
        "parentId": null,
        "type": "title",
        "children": [
          {
            "id": "article-1",
            "number": 1,
            "name": "Η Ελληνική Ομοσπονδία",
            "content": "μπλα μπλα μπλα...",
            "parentId": "title-1",
            "type": "article"
          },
          {
            "id": "article-2",
            "number": 2,
            "name": "Περιφέρειες",
            "content": "μπλα μπλα μπλα...",
            "parentId": "title-1",
            "type": "article"
          },
          {
            "id": "chapter-1",
            "number": 1,
            "name": "Η Ομοσπονδία",
            "content": null,
            "parentId": "title-1",
            "type": "chapter",
            "children": [
              // ... άρθρα του κεφαλαίου 1
            ]
          }
        ]
      }
      // ...επόμενοι τίτλοι
    ]
    ```

Αυτό το σχήμα επιτρέπει στο frontend να εμφανίσει όλα τα δεδομένα με τη σωστή ιεραρχία και σειρά, με μια μόνο κλήση. Η λογική που περιέγραψες είναι όχι μόνο εφικτή, αλλά και τεχνικά άριστη για αυτόν τον σκοπό.